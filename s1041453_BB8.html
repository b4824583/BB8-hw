<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - geometry - cube</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				margin: 0px;
				background-color: #000000;
				overflow: hidden;
			}
		</style>
	</head>
	<body>
		<script src="three.js/build/three.r89.min.js"></script>
		<script src="js/controls/OrbitControls.js"></script>
		<script src="js/libs/dat.gui.min.js"></script>

		<script>
			"use strict";
			var controls;
			var light, light2, light3;
			var camera, scene, renderer;
			var mesh, head;
			//[[0,0],[1,1],[1,0],[1,-1],[0,-1],[-1,-1],[-1,0],[-1,1]];
			//var ofset = [[0,0],[1,1],[1,0],[1,-1],[0,-1],[-1,-1],[-1,0],[-1,1]];

			var gravity = -9.8; // 向上為正
			var velocity = 0;
			var heading = 0;
			var jumpVelocity = 0;
			var lastTime;

			var gui, params;
			var guiMe = function() {
			  this.Heading = heading;
			  this.Velocity = velocity;
			  this.addSpeed = 10;
			  this.rotSpeed = 5;
			  this.Stop = function() {
			   	velocity = 0;
			  	this.Velocity = velocity;
			  };
			  this.FollowMe = false;
			};

			init();

			lastTime = Date.now();
			
			animate();

			function init() {

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 10, 5000 );
				camera.position.y = 500;
				camera.position.z = 400;

				scene = new THREE.Scene();
				
				// create a light
				light = new THREE.DirectionalLight(0xffffff);
				light.position.set(100,200,400);
				scene.add(light);
				light2 = new THREE.DirectionalLight(0xffffff);
				light2.position.set(-400,200,-400);
				scene.add(light2);
				light3 = new THREE.DirectionalLight(0xffffff);
				light3.position.set(100,-400,-400);
				scene.add(light3);

				// add a ground plane
				var texture = new THREE.TextureLoader().load( 'textures/UV_Grid_Sm.jpg' );
				var geometry = new THREE.PlaneGeometry( 1000, 1000 );
				var material = new THREE.MeshPhongMaterial( {map: texture, side: THREE.DoubleSide} );
				var plane = new THREE.Mesh( geometry, material );
				plane.rotation.x = -90 * Math.PI / 180;
				plane.position.y = 0.0;
				scene.add( plane );

				var axisHelper = new THREE.AxesHelper( 200 );
				scene.add( axisHelper );

				texture = new THREE.TextureLoader().load( 'textures/BB8-Head.jpg' );
				geometry = new THREE.SphereGeometry( 25, 32, 16 );
				material = new THREE.MeshPhongMaterial( { map: texture } );
				head = new THREE.Mesh( geometry, material );
				head.rotation.y = -90 * Math.PI / 180;
				head.position.y = 100.01;
				scene.add( head );

				texture = new THREE.TextureLoader().load( 'textures/BB8.jpg' );
				geometry = new THREE.SphereGeometry( 50, 32, 16);
				material = new THREE.MeshPhongMaterial( { map: texture } );
				mesh = new THREE.Mesh( geometry, material );
				mesh.rotation.y = 90 * Math.PI / 180;
				mesh.position.y = 50.01;
				scene.add( mesh );

				

				renderer = new THREE.WebGLRenderer();

				// set the background color to gray
				renderer.setClearColor( 0xa0a0a0 );

				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				// let's have the mouse affect the view
				controls = new THREE.OrbitControls( camera, renderer.domElement );

				window.addEventListener( 'resize', onWindowResize, false );

				// add some GUI
				params = new guiMe();
				gui = new dat.GUI();

				gui.add(params, 'Heading').listen();
				gui.add(params, 'Velocity').listen();
				gui.add(params, 'addSpeed', 0, 30);
				gui.add(params, 'rotSpeed', 0, 30);
				gui.add(params, 'Stop');
				gui.add(params, 'FollowMe');
				gui.open();

				window.onkeydown = function( event ) {
			        var key = String.fromCharCode(event.keyCode);
			        switch( key ) {
			          case 'w': case 'W':
							velocity += params.addSpeed;
							params.Velocity = velocity;

							break;
			          case 's': case 'S':
			          		velocity -= params.addSpeed;
							params.Velocity = velocity;
							
							break;
			          case 'a': case 'A':
			          		mesh.rotateOnWorldAxis ( new THREE.Vector3( 0, 1, 0 ), params.rotSpeed * Math.PI / 180);
			          		heading += params.rotSpeed;
			          		if(heading >= 360)
			          		{
			          			heading -= 360;
			          		}
			          		
							break;
			          case 'd': case 'D':
			          		mesh.rotateOnWorldAxis ( new THREE.Vector3( 0, -1, 0 ), params.rotSpeed * Math.PI / 180);
			          		heading -= params.rotSpeed;
			          		if(heading <= -360)
			          		{
			          			heading += 360;
			          		}
							break;
					  case ' ':
					  		jumpVelocity = 40;
					  		break;
			        }
			    };
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function animate() {
				requestAnimationFrame( animate );
				// Rotate the wheel
				var deltaTime = Date.now() - lastTime;
				lastTime = Date.now();
				mesh.rotateOnAxis ( new THREE.Vector3( 0, 0, 1 ),velocity / 50 *deltaTime / 1000.0);

				var positionX = mesh.position.x + Math.sin(heading* Math.PI / 180)*params.Velocity*deltaTime / 1000.0;
				var positionZ = mesh.position.z + Math.cos(heading* Math.PI / 180)*params.Velocity*deltaTime / 1000.0;
				head.position.x = mesh.position.x =  (positionX > 500)? 500 : (positionX < -500)? -500 : positionX;
				head.position.z = mesh.position.z =  (positionZ > 500)? 500 : (positionZ < -500)? -500 : positionZ;
				

				if(jumpVelocity != 0)
				{
					jumpVelocity = (jumpVelocity + gravity * deltaTime / 100.0);
					var Displacement = jumpVelocity * deltaTime / 100.0 + 1/2 * gravity * deltaTime / 100.0 * deltaTime / 100.0;
					var positionY = mesh.position.y + Displacement;

					if(positionY < 50.1)
					{
						mesh.position.y = 50.1;
						head.position.y = 100.1;
						jumpVelocity = 0;
					}
					else {
						mesh.position.y +=Displacement;
						head.position.y +=Displacement; 
					}

						
					
					//mesh.position.y +=  (positionY >= 50.1)? Displacement : 50.1;
					//head.position.y += (positionY >= 50.1)? Displacement : 100.1;
				}

				//or rotateOnWorldAxis?? check the document :)
				
				// Move the body & head

				// Camera now following the BB8
				if(params.FollowMe){
					camera.position.x = head.position.x;
					camera.position.z = head.position.z;
					camera.position.z += 500;
					camera.rotation.x = -50 * Math.PI / 180;
					camera.rotation.y = 0;
					camera.rotation.z = 0;
				}

				params.Velocity = velocity;
				params.Heading = heading;

				renderer.render( scene, camera );
				// have the mouse update the view
				controls.update();

			}
		</script>
	</body>
</html>
